// Code generated by Prisma Client Rust. DO NOT EDIT.

#![allow(warnings, unused)]
use prisma_client_rust::datamodel::parse_configuration;
use prisma_client_rust::prisma_models::InternalDataModelBuilder;
use prisma_client_rust::query::{
    transform_equals, Field, Input, Output, Query, QueryContext, Result as QueryResult,
};
use prisma_client_rust::query_core::{
    executor, schema_builder, BuildMode, CoreError, InterpreterError, QueryExecutor,
    QueryGraphBuilderError, QuerySchema,
};
use prisma_client_rust::{chrono, operator::Operator, serde_json, CountResult, Direction};
pub use prisma_client_rust::{query::Error as QueryError, NewClientError};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
static DATAMODEL_STR : & 'static str = "datasource db {\n  provider = \"sqlite\"\n  url      = \"file:dev.db\"\n}\n\ngenerator client {\n  provider = \"cargo prisma\"\n  output   = \"../src/prisma.rs\"\n}\n\nmodel User {\n  id          String @id @default(uuid())\n  displayName String\n  posts       Post[]\n}\n\nmodel Post {\n  id      String @id @default(uuid())\n  content String\n  user    User   @relation(fields: [userId], references: [id])\n  userId  String\n}\n" ;
pub struct PrismaClient {
    executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
    query_schema: Arc<QuerySchema>,
}
pub async fn new_client() -> Result<PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let url = if let Some(url) = source.load_shadow_database_url()? {
        url
    } else {
        source.load_url(|key| std::env::var(key).ok())?
    };
    let url = if url.starts_with("file:") {
        let path = url.split(":").nth(1).unwrap();
        if Path::new("./schema.prisma").exists() {
            url
        } else if Path::new("./prisma/schema.prisma").exists() {
            format!("file:./prisma/{}", path)
        } else {
            url
        }
    } else {
        url
    };
    new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> Result<PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let (db_name, executor) = executor::load(&source, &[], &url).await?;
    let internal_model = InternalDataModelBuilder::new(DATAMODEL_STR).build(db_name);
    let query_schema = Arc::new(schema_builder::build(
        internal_model,
        BuildMode::Modern,
        true,
        source.capabilities(),
        vec![],
        source.referential_integrity(),
    ));
    executor.primary_connector().get_connection().await?;
    Ok(PrismaClient {
        executor,
        query_schema,
    })
}
impl PrismaClient {
    pub async fn _query_raw<T: serde::de::DeserializeOwned>(
        &self,
        query: &str,
    ) -> QueryResult<Vec<T>> {
        let query = Query {
            ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
            operation: "mutation".into(),
            method: "queryRaw".into(),
            inputs: vec![
                Input {
                    name: "query".into(),
                    value: Some(query.into()),
                    ..Default::default()
                },
                Input {
                    name: "parameters".into(),
                    value: Some("[]".into()),
                    ..Default::default()
                },
            ],
            name: "".into(),
            model: "".into(),
            outputs: vec![],
        };
        query.perform().await
    }
    pub async fn _execute_raw(&self, query: &str) -> QueryResult<i64> {
        let query = Query {
            ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
            operation: "mutation".into(),
            method: "executeRaw".into(),
            inputs: vec![
                Input {
                    name: "query".into(),
                    value: Some(query.into()),
                    ..Default::default()
                },
                Input {
                    name: "parameters".into(),
                    value: Some("[]".into()),
                    ..Default::default()
                },
            ],
            name: "".into(),
            model: "".into(),
            outputs: vec![],
        };
        query.perform().await.map(|result: i64| result)
    }
    pub fn user(&self) -> user::Actions {
        user::Actions { client: &self }
    }
    pub fn post(&self) -> post::Actions {
        post::Actions { client: &self }
    }
}
pub mod user {
    use super::*;
    pub mod id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod display_name {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DisplayNameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DisplayName(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DisplayNameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DisplayNameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DisplayNameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DisplayNameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DisplayNameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DisplayNameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DisplayNameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DisplayNameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DisplayNameEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DisplayNameNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDisplayName(value.0)
            }
        }
    }
    pub mod posts {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<post::WhereParam>) -> WhereParam {
            WhereParam::PostsSome(value)
        }
        pub fn every(value: Vec<post::WhereParam>) -> WhereParam {
            WhereParam::PostsEvery(value)
        }
        pub fn none(value: Vec<post::WhereParam>) -> WhereParam {
            WhereParam::PostsNone(value)
        }
        pub fn fetch(params: Vec<post::WhereParam>) -> WithParam {
            WithParam::Posts(params)
        }
        pub fn link<T: From<Link>>(params: Vec<post::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<post::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkPosts(params)
        }
        pub struct Link(Vec<post::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkPosts(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Output> {
        vec![Output::new("id"), Output::new("displayName")]
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "displayName")]
        pub display_name: String,
        #[serde(rename = "posts")]
        posts: Option<Vec<super::post::Data>>,
    }
    impl Data {
        pub fn posts(&self) -> Result<&Vec<super::post::Data>, String> {
            match self.posts.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access posts but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        Posts(Vec<super::post::WhereParam>),
    }
    impl WithParam {
        pub fn to_output(self) -> Output {
            match self {
                Self::Posts(where_params) => Output {
                    name: "posts".into(),
                    outputs: super::post::_outputs(),
                    inputs: if where_params.len() > 0 {
                        vec![Input {
                            name: "where".into(),
                            fields: where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::post::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                            ..Default::default()
                        }]
                    } else {
                        vec![]
                    },
                    ..Default::default()
                },
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetDisplayName(String),
        LinkPosts(Vec<super::post::UniqueWhereParam>),
        UnlinkPosts(Vec<super::post::UniqueWhereParam>),
    }
    impl SetParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::SetId(value) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetDisplayName(value) => Field {
                    name: "displayName".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::LinkPosts(where_params) => Field {
                    name: "posts".into(),
                    fields: Some(vec![Field {
                        name: "connect".into(),
                        fields: Some(transform_equals(
                            where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::post::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                        )),
                        list: true,
                        wrap_list: true,
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UnlinkPosts(where_params) => Field {
                    name: "posts".into(),
                    fields: Some(vec![Field {
                        name: "disconnect".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(transform_equals(
                            where_params
                                .into_iter()
                                .map(|param| {
                                    Into::<super::post::WhereParam>::into(param).to_field()
                                })
                                .collect(),
                        )),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        DisplayName(Direction),
    }
    impl OrderByParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Id(direction) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::DisplayName(direction) => Field {
                    name: "displayName".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum Cursor {
        Id(String),
        DisplayName(String),
    }
    impl Cursor {
        fn to_field(self) -> Field {
            match self {
                Self::Id(value) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::DisplayName(value) => Field {
                    name: "displayName".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdNot(String),
        DisplayNameEquals(String),
        DisplayNameInVec(Vec<String>),
        DisplayNameNotInVec(Vec<String>),
        DisplayNameLt(String),
        DisplayNameLte(String),
        DisplayNameGt(String),
        DisplayNameGte(String),
        DisplayNameContains(String),
        DisplayNameStartsWith(String),
        DisplayNameEndsWith(String),
        DisplayNameNot(String),
        PostsSome(Vec<super::post::WhereParam>),
        PostsEvery(Vec<super::post::WhereParam>),
        PostsNone(Vec<super::post::WhereParam>),
    }
    impl WhereParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Not(value) => Field {
                    name: "NOT".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::Or(value) => Field {
                    name: "OR".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::And(value) => Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::IdEquals(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdInVec(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdNotInVec(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdLt(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdLte(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdGt(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdGte(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdContains(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdStartsWith(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdEndsWith(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdNot(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DisplayNameEquals(value) => Field {
                    name: "displayName".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DisplayNameInVec(value) => Field {
                    name: "displayName".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DisplayNameNotInVec(value) => Field {
                    name: "displayName".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DisplayNameLt(value) => Field {
                    name: "displayName".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DisplayNameLte(value) => Field {
                    name: "displayName".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DisplayNameGt(value) => Field {
                    name: "displayName".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DisplayNameGte(value) => Field {
                    name: "displayName".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DisplayNameContains(value) => Field {
                    name: "displayName".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DisplayNameStartsWith(value) => Field {
                    name: "displayName".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DisplayNameEndsWith(value) => Field {
                    name: "displayName".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::DisplayNameNot(value) => Field {
                    name: "displayName".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PostsSome(value) => Field {
                    name: "posts".into(),
                    fields: Some(vec![Field {
                        name: "some".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PostsEvery(value) => Field {
                    name: "posts".into(),
                    fields: Some(vec![Field {
                        name: "every".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::PostsNone(value) => Field {
                    name: "posts".into(),
                    fields: Some(vec![Field {
                        name: "none".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub struct FindMany<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            DeleteMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteMany".into(),
                    model: "User".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateMany".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindFirst<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> Delete<'a> {
            Delete {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteOne".into(),
                    model: "User".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateUnique {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateOne".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct Create<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> UpdateUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateMany<'a> {
        query: Query<'a>,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Upsert<'a> {
        query: Query<'a>,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            self.query.perform().await
        }
        pub fn create(mut self, display_name: display_name::Set, params: Vec<SetParam>) -> Self {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(display_name).to_field());
            self.query.inputs.push(Input {
                name: "create".into(),
                fields: input_fields,
                ..Default::default()
            });
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.query.inputs.push(Input {
                name: "update".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            self
        }
    }
    pub struct Delete<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct DeleteMany<'a> {
        query: Query<'a>,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(&self, display_name: display_name::Set, params: Vec<SetParam>) -> Create {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(display_name).to_field());
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "createOne".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "data".into(),
                    fields: input_fields,
                    ..Default::default()
                }],
            };
            Create {
                query,
                with_params: vec![],
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findUnique".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            FindUnique {
                query,
                with_params: vec![],
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: vec![Field {
                        name: "AND".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(where_fields),
                        ..Default::default()
                    }],
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findFirst".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs,
            };
            FindFirst {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: where_fields,
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findMany".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs,
            };
            FindMany {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "upsertOne".into(),
                model: "User".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            Upsert { query }
        }
    }
}
pub mod post {
    use super::*;
    pub mod id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod content {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ContentEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Content(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ContentInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ContentNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ContentLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ContentLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ContentGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ContentGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ContentContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ContentStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ContentEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ContentNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetContent(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub fn fetch() -> WithParam {
            WithParam::User
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UserIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UserIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UserIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Output> {
        vec![
            Output::new("id"),
            Output::new("content"),
            Output::new("userId"),
        ]
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "content")]
        pub content: String,
        #[serde(rename = "user")]
        user: Option<Box<super::user::Data>>,
        #[serde(rename = "userId")]
        pub user_id: String,
    }
    impl Data {
        pub fn user(&self) -> Result<&super::user::Data, String> {
            match self.user.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access user but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        User,
    }
    impl WithParam {
        pub fn to_output(self) -> Output {
            match self {
                Self::User => Output {
                    name: "user".into(),
                    outputs: super::user::_outputs(),
                    ..Default::default()
                },
            }
        }
    }
    pub enum SetParam {
        SetId(String),
        SetContent(String),
        LinkUser(super::user::UniqueWhereParam),
        SetUserId(String),
    }
    impl SetParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::SetId(value) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::SetContent(value) => Field {
                    name: "content".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::LinkUser(where_param) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "connect".into(),
                        fields: Some(transform_equals(vec![
                            Into::<super::user::WhereParam>::into(where_param).to_field(),
                        ])),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::SetUserId(value) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        Content(Direction),
        UserId(Direction),
    }
    impl OrderByParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Id(direction) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::Content(direction) => Field {
                    name: "content".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
                Self::UserId(direction) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(direction).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum Cursor {
        Id(String),
        Content(String),
        UserId(String),
    }
    impl Cursor {
        fn to_field(self) -> Field {
            match self {
                Self::Id(value) => Field {
                    name: "id".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::Content(value) => Field {
                    name: "content".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
                Self::UserId(value) => Field {
                    name: "userId".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                },
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdNot(String),
        ContentEquals(String),
        ContentInVec(Vec<String>),
        ContentNotInVec(Vec<String>),
        ContentLt(String),
        ContentLte(String),
        ContentGt(String),
        ContentGte(String),
        ContentContains(String),
        ContentStartsWith(String),
        ContentEndsWith(String),
        ContentNot(String),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(String),
        UserIdInVec(Vec<String>),
        UserIdNotInVec(Vec<String>),
        UserIdLt(String),
        UserIdLte(String),
        UserIdGt(String),
        UserIdGte(String),
        UserIdContains(String),
        UserIdStartsWith(String),
        UserIdEndsWith(String),
        UserIdNot(String),
    }
    impl WhereParam {
        pub fn to_field(self) -> Field {
            match self {
                Self::Not(value) => Field {
                    name: "NOT".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::Or(value) => Field {
                    name: "OR".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::And(value) => Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                },
                Self::IdEquals(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdInVec(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdNotInVec(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdLt(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdLte(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdGt(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdGte(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdContains(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdStartsWith(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdEndsWith(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::IdNot(value) => Field {
                    name: "id".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ContentEquals(value) => Field {
                    name: "content".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ContentInVec(value) => Field {
                    name: "content".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ContentNotInVec(value) => Field {
                    name: "content".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ContentLt(value) => Field {
                    name: "content".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ContentLte(value) => Field {
                    name: "content".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ContentGt(value) => Field {
                    name: "content".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ContentGte(value) => Field {
                    name: "content".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ContentContains(value) => Field {
                    name: "content".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ContentStartsWith(value) => Field {
                    name: "content".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ContentEndsWith(value) => Field {
                    name: "content".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::ContentNot(value) => Field {
                    name: "content".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIs(value) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "is".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIsNot(value) => Field {
                    name: "user".into(),
                    fields: Some(vec![Field {
                        name: "isNot".into(),
                        fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdEquals(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "equals".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdInVec(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "in".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdNotInVec(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "notIn".into(),
                        list: true,
                        fields: Some(
                            value
                                .iter()
                                .map(|v| Field {
                                    value: Some(serde_json::to_value(v).unwrap()),
                                    ..Default::default()
                                })
                                .collect(),
                        ),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdLt(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "lt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdLte(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "lte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdGt(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "gt".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdGte(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "gte".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdContains(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "contains".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdStartsWith(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "startsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdEndsWith(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "endsWith".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
                Self::UserIdNot(value) => Field {
                    name: "userId".into(),
                    fields: Some(vec![Field {
                        name: "not".into(),
                        value: Some(serde_json::to_value(value).unwrap()),
                        ..Default::default()
                    }]),
                    ..Default::default()
                },
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub struct FindMany<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            DeleteMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteMany".into(),
                    model: "Post".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateMany {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateMany".into(),
                    outputs: vec![Output::new("count")],
                    ..self.query
                },
            }
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindFirst<'a> {
        query: Query<'a>,
        order_by_params: Vec<OrderByParam>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                order_by_params,
                with_params,
            } = self;
            if order_by_params.len() > 0 {
                query.inputs.push(Input {
                    name: "orderBy".into(),
                    fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                    ..Default::default()
                });
            }
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.order_by_params.push(param);
            self
        }
        pub fn skip(mut self, skip: usize) -> Self {
            self.query.inputs.push(Input {
                name: "skip".into(),
                value: Some(serde_json::to_value(skip).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn take(mut self, take: usize) -> Self {
            self.query.inputs.push(Input {
                name: "take".into(),
                value: Some(serde_json::to_value(take).unwrap()),
                ..Default::default()
            });
            self
        }
        pub fn cursor(mut self, cursor: Cursor) -> Self {
            self.query.inputs.push(Input {
                name: "cursor".into(),
                fields: vec![cursor.to_field()],
                ..Default::default()
            });
            self
        }
    }
    pub struct FindUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn delete(self) -> Delete<'a> {
            Delete {
                query: Query {
                    operation: "mutation".into(),
                    method: "deleteOne".into(),
                    model: "Post".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
            self.query.inputs.push(Input {
                name: "data".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            UpdateUnique {
                query: Query {
                    operation: "mutation".into(),
                    method: "updateOne".into(),
                    ..self.query
                },
                with_params: vec![],
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct Create<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            query.perform().await
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateUnique<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> UpdateUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct UpdateMany<'a> {
        query: Query<'a>,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Upsert<'a> {
        query: Query<'a>,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            self.query.perform().await
        }
        pub fn create(
            mut self,
            content: content::Set,
            user: user::Link,
            params: Vec<SetParam>,
        ) -> Self {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(content).to_field());
            input_fields.push(SetParam::from(user).to_field());
            self.query.inputs.push(Input {
                name: "create".into(),
                fields: input_fields,
                ..Default::default()
            });
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.query.inputs.push(Input {
                name: "update".into(),
                fields: params
                    .into_iter()
                    .map(|param| {
                        let mut field = param.to_field();
                        if let Some(value) = field.value {
                            field.fields = Some(vec![Field {
                                name: "set".into(),
                                value: Some(value),
                                ..Default::default()
                            }]);
                            field.value = None;
                        }
                        field
                    })
                    .collect(),
                ..Default::default()
            });
            self
        }
    }
    pub struct Delete<'a> {
        query: Query<'a>,
        with_params: Vec<WithParam>,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self {
                mut query,
                with_params,
            } = self;
            query.outputs.extend(
                with_params
                    .into_iter()
                    .map(|f| f.to_output())
                    .collect::<Vec<_>>(),
            );
            match query.perform().await {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, param: WithParam) -> Self {
            self.with_params.push(param);
            self
        }
    }
    pub struct DeleteMany<'a> {
        query: Query<'a>,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<usize> {
            self.query.perform().await.map(|res: CountResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            content: content::Set,
            user: user::Link,
            params: Vec<SetParam>,
        ) -> Create {
            let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
            input_fields.push(SetParam::from(content).to_field());
            input_fields.push(SetParam::from(user).to_field());
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "createOne".into(),
                model: "Post".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "data".into(),
                    fields: input_fields,
                    ..Default::default()
                }],
            };
            Create {
                query,
                with_params: vec![],
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findUnique".into(),
                model: "Post".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            FindUnique {
                query,
                with_params: vec![],
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: vec![Field {
                        name: "AND".into(),
                        list: true,
                        wrap_list: true,
                        fields: Some(where_fields),
                        ..Default::default()
                    }],
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findFirst".into(),
                model: "Post".into(),
                outputs: _outputs(),
                inputs,
            };
            FindFirst {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            let where_fields: Vec<Field> =
                params.into_iter().map(|param| param.to_field()).collect();
            let inputs = if where_fields.len() > 0 {
                vec![Input {
                    name: "where".into(),
                    fields: where_fields,
                    ..Default::default()
                }]
            } else {
                Vec::new()
            };
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "query".into(),
                method: "findMany".into(),
                model: "Post".into(),
                outputs: _outputs(),
                inputs,
            };
            FindMany {
                query,
                order_by_params: vec![],
                with_params: vec![],
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            let param: WhereParam = param.into();
            let fields = transform_equals(vec![param.to_field()]);
            let query = Query {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                name: String::new(),
                operation: "mutation".into(),
                method: "upsertOne".into(),
                model: "Post".into(),
                outputs: _outputs(),
                inputs: vec![Input {
                    name: "where".into(),
                    fields,
                    ..Default::default()
                }],
            };
            Upsert { query }
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum UserScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "displayName")]
    DisplayName,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum PostScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "content")]
    Content,
    #[serde(rename = "userId")]
    UserId,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum SortOrder {
    #[serde(rename = "asc")]
    Asc,
    #[serde(rename = "desc")]
    Desc,
}
